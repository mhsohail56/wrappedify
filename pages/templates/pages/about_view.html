{% extends 'pages/pre_base.html' %}

{% block title %}About{% endblock %}
{% block bannerlink %}href="/" {% endblock %}

{% block main %}
<div style="width: 100%; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:justify">
    <h1>About Wrappedify.</h1>
    <p style="font-size:11pt; width: 75%">We all know and love <a href="https://en.wikipedia.org/wiki/Spotify_Wrapped" style="color:white" target="_blank" rel="noopener noreferrer">Spotify Wrapped</a>. For those who don't know, Spotify Wrapped is a year-end campaign put forth by the music streaming service which aims to provide users with a summary of their listening throughout the year. From a share-friendly interface to personalized messages—which may or may not end up falling victim to the trend of corporate humanization—Spotify Wrapped is any music junkie's dream.</p>
    <p style="font-size:11pt; width: 75%">Now, although Spotify's end-of-the year summary may satisfy the average listener, those who are a little more data savvy beg to differ. With this in mind, I created Wrappedify, a service which strives to offer all the personalised data offered by Spotify Wrapped, and more (without the cringey bits)! From your musical favourites, to more concrete statistics such as listening activity over different time periods, Wrappedify allows you to view your listening on demand.</p>
    <h3 style="font-family:CircularStd-Black">Now, for the nitty gritty.</h3>
    <p style="font-size:11pt; width: 75%">Wrappedify is built using Python's <a href="https://www.djangoproject.com" style="color:white" target="_blank" rel="noopener noreferrer">Django</a> framework, allowing me to maintain a favourable backend for the data analysis. Interactions with Spotify's Web API were made using <a href="https://spotipy.readthedocs.io/en/2.19.0/" style="color:white" target="_blank" rel="noopener noreferrer">spotipy</a>, a Python library which makes dealing with the API much simpler. The data analysis consists of two phases: the first phase involves parsing the JSON data provided, and the second, heavier phase, involves multiple calls to the Web API. The second phase is heavier as it takes the longest, accounting for the waiting time on the processing page. This long running task raised a problem for the website's UX. If the page waited for the task to complete in order to load, the user would assume a problem with their internet connection. To solve this, I used <a href="https://docs.celeryproject.org/en/stable/index.html" style="color:white" target="_blank" rel="noopener noreferrer">Celery</a>, which I'll discuss in a bit.</p>
    <p style="font-size:11pt; width: 75%">The front end is implemented with good ol' HTML5, CSS, and JavaScript, making use of AJAX and JQuery, as well. The genre bubble graphic and the activity charts were both made using <a href="https://d3js.org" style="color:white" target="_blank" rel="noopener noreferrer">D3.js</a>, a robust JavaScript library used for visualising data on the web. The website's UI was made in part by keeping Spotify's own interface in mind while also taking inspiration from <a href="https://medium.com/front-end-weekly/how-i-built-a-miniature-year-round-available-version-of-spotify-wrapped-e7625a30b58b" style="color:white" target="_blank" rel="noopener noreferrer">Statify</a>, another amazing service for understanding your Spotify listening.</p>
    <p style="font-size:11pt; width: 75%">Perhaps the most difficult component to implement was the seemingly simple progress bar. Much of my process is detailed in <a href="https://buildwithdjango.com/blog/post/celery-progress-bars/" style="color:white" target="_blank" rel="noopener noreferrer">an article</a> by Cory Zue that I used as a guide. In short, the progress bar was implemented using asynchronous task queues (Celery) and a message broker (<a href="https://redis.io" style="color:white" target="_blank" rel="noopener noreferrer">Redis</a>). The <em>client</em>, Django in our case, is responsible for the creation of the asynchronous task (the API heavy analysis). The creation of this task is then communicated to the asynchronous queue via the message broker. After the task begins, the progress between the queue and the client (i.e., the webpage) is relayed through the message broker. With every update received, the progress bar advances with the help of JavaScript.</p>
    <p style="font-size:11pt; width: 75%">In any case, this project was a wonderful full-stack learning experience which introduced me to various technologies. I hope, like myself, you also enjoy using Wrappedify to better understand your listening :)</p>
</div>
{% endblock %}